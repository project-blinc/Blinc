// WARNING: This file is machine generated by fidlgen.


#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
    fidl::{
        endpoints::{ControlHandle as _, Responder as _},
        client::QueryResponseFut,
    },
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

pub type QuaternionF = Vec4F;

/// An integer offset to apply to each edge of a rectangle.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Inset{
    /// The amount to move the top edge of the rectangle towards the center of
    /// the rectangle.
    pub top: i32,
    /// The amount to move the right edge of the rectangle towards the center of
    /// the rectangle.
    pub right: i32,
    /// The amount to move the bottom edge of the rectangle towards the center
    /// of the rectangle.
    pub bottom: i32,
    /// The amount to move the left edge of the rectangle towards the center of
    /// the rectangle.
    pub left: i32,
}

impl fidl::Persistable for Inset {}

/// A floating point offset to apply to each edge of a rectangle.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct InsetF{
    /// The amount to move the top edge of the rectangle towards the center of
    /// the rectangle.
    pub top: f32,
    /// The amount to move the right edge of the rectangle towards the center of
    /// the rectangle.
    pub right: f32,
    /// The amount to move the bottom edge of the rectangle towards the center
    /// of the rectangle.
    pub bottom: f32,
    /// The amount to move the left edge of the rectangle towards the center of
    /// the rectangle.
    pub left: f32,
}

impl fidl::Persistable for InsetF {}

/// An integer position in a 2D cartesian space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Point{
    /// The number of units along the x-axis.
    pub x: i32,
    /// The number of units along the y-axis.
    pub y: i32,
}

impl fidl::Persistable for Point {}

/// A floating point position in a 3D cartesian space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Point3F{
    /// The number of units along the x-axis.
    pub x: f32,
    /// The number of units along the y-axis.
    pub y: f32,
    /// The number of units along the z-axis.
    pub z: f32,
}

impl fidl::Persistable for Point3F {}

/// A floating point position in a 2D cartesian space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct PointF{
    /// The number of units along the x-axis.
    pub x: f32,
    /// The number of units along the y-axis.
    pub y: f32,
}

impl fidl::Persistable for PointF {}

/// A floating point rounded rectangle with the custom radii for all four
/// corners.
///
/// A region in a 2D cartesian space consisting of linear, axis-aligned sides
/// with corners rounded into a quarter ellipse.
///
/// If the quarter ellipses in two corners would overlap, their radii are
/// clamped such that the ellipses meet with an axis-aligned tangent.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct RRectF{
    /// The location of the origin of the region in the x-axis.
    pub x: f32,
    /// The location of the origin of the region in the y-axis.
    pub y: f32,
    /// The distance along the x-axis.
    ///
    /// If `width` is positive, the region includes x values starting at `x` and
    /// increasing along the x-axis. If `width` is negative, the region includes
    /// x values starting at `x` and decreasing along the x-axis.
    pub width: f32,
    /// The distance along the y-axis.
    ///
    /// If `height` is positive, the region includes y values starting at `y`
    /// and increasing along the y-axis. If `height` is negative, the region
    /// includes y values starting at `y` and decreasing along the y-axis.
    pub height: f32,
    /// The radius of the quarter ellipse in the top-left corner along the
    /// x-axis.
    ///
    /// Must not be negative.
    pub top_left_radius_x: f32,
    /// The radius of the quarter ellipse in the top-left corner along the
    /// y-axis.
    ///
    /// Must not be negative.
    pub top_left_radius_y: f32,
    /// The radius of the quarter ellipse in the top-right corner along the
    /// x-axis.
    ///
    /// Must not be negative.
    pub top_right_radius_x: f32,
    /// The radius of the quarter ellipse in the top-right corner along the
    /// y-axis.
    ///
    /// Must not be negative.
    pub top_right_radius_y: f32,
    /// The radius of the quarter ellipse in the bottom-left corner along the
    /// x-axis.
    ///
    /// Must not be negative.
    pub bottom_left_radius_x: f32,
    /// The radius of the quarter ellipse in the bottom-left corner along the
    /// y-axis.
    ///
    /// Must not be negative.
    pub bottom_left_radius_y: f32,
    /// The radius of the quarter ellipse in the bottom-right corner along the
    /// x-axis.
    ///
    /// Must not be negative.
    pub bottom_right_radius_x: f32,
    /// The radius of the quarter ellipse in the bottom-right corner along the
    /// y-axis.
    ///
    /// Must not be negative.
    pub bottom_right_radius_y: f32,
}

impl fidl::Persistable for RRectF {}

/// A ratio of unsigned 32-bit numbers.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct RatioU32{
    /// The numerator.
    pub numerator: u32,
    /// The denominator.
    pub denominator: u32,
}

impl fidl::Persistable for RatioU32 {}

/// A ratio of unsigned 64-bit numbers.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct RatioU64{
    /// The numerator.
    pub numerator: u64,
    /// The denominator.
    pub denominator: u64,
}

impl fidl::Persistable for RatioU64 {}

/// An integral, rectangular, axis-aligned region in a 2D cartesian
/// space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Rect{
    /// The location of the origin of the rectangle in the x-axis.
    pub x: i32,
    /// The location of the origin of the rectangle in the y-axis.
    pub y: i32,
    /// The distance along the x-axis.
    ///
    /// If `width` is positive, the region includes x values starting at `x` and
    /// increasing along the x-axis. If `width` is negative, the region includes
    /// x values starting at `x` and decreasing along the x-axis.
    pub width: i32,
    /// The distance along the y-axis.
    ///
    /// If `height` is positive, the region includes y values starting at `y`
    /// and increasing along the y-axis. If `height` is negative, the region
    /// includes y values starting at `y` and decreasing along the y-axis.
    pub height: i32,
}

impl fidl::Persistable for Rect {}

/// A floating point, rectangular, axis-aligned region in a 2D cartesian
/// space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct RectF{
    /// The location of the origin of the rectangle in the x-axis.
    pub x: f32,
    /// The location of the origin of the rectangle in the y-axis.
    pub y: f32,
    /// The distance along the x-axis.
    ///
    /// If `width` is positive, the region includes x values starting at `x` and
    /// increasing along the x-axis. If `width` is negative, the region includes
    /// x values starting at `x` and decreasing along the x-axis.
    pub width: f32,
    /// The distance along the y-axis.
    ///
    /// If `height` is positive, the region includes y values starting at `y`
    /// and increasing along the y-axis. If `height` is negative, the region
    /// includes y values starting at `y` and decreasing along the y-axis.
    pub height: f32,
}

impl fidl::Persistable for RectF {}

/// An integral, rectangular, axis-aligned region in a 2D cartesian
/// space, with unsigned location and distance fields.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct RectU{
    /// The location of the origin of the rectangle in the x-axis.
    pub x: u32,
    /// The location of the origin of the rectangle in the y-axis.
    pub y: u32,
    /// The distance along the x-axis.
    ///
    /// The region includes x values starting at `x` and increasing along the
    /// x-axis.
    pub width: u32,
    /// The distance along the y-axis.
    ///
    /// The region includes y values starting at `y` and increasing along the
    /// y-axis.
    pub height: u32,
}

impl fidl::Persistable for RectU {}

/// The integer dimensions of a rectangular region in a 2D cartesian space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
///
/// This type allows for negative dimensions, to which protocols can give
/// semantics. Protocols that use this type should specify whether negative
/// dimensions are meaningful, and, if they are meaningful, what they mean.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Size{
    /// The distance along the x-axis.
    pub width: i32,
    /// The distance along the y-axis.
    pub height: i32,
}

impl fidl::Persistable for Size {}

/// The floating point dimensions of a rectangular region in a 2D cartesian
/// space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
///
/// This type allows for negative dimensions, to which protocols can give
/// semantics. Protocols that use this type should specify whether negative
/// dimensions are meaningful, and, if they are meaningful, what they mean.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct SizeF{
    /// The distance along the x-axis.
    pub width: f32,
    /// The distance along the y-axis.
    pub height: f32,
}

impl fidl::Persistable for SizeF {}

/// The unsigned integer dimensions of a rectangular region in a 2D cartesian
/// space.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct SizeU{
    /// The distance along the x-axis.
    pub width: u32,
    /// The distance along the y-axis.
    pub height: u32,
}

impl fidl::Persistable for SizeU {}

/// A projective transformation of a 3D cartesian space.
///
/// A transform consists of a 4x4 matrix that operates in homogeneous
/// coordinates. For example, a point located at (x, y, z) in the cartesian
/// space is transformed by `M` to a point located at (x'/w', y'/w', z'/w'),
/// where `(x', y', z', w') = M (x, y, z, 1)`.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Transform{
    /// The entries in the transformation matrix in row major order.
    ///
    /// Specifically, if the matrix is as follows:
    ///
    /// ```
    /// a b c d
    /// e f g h
    /// i j k l
    /// m n o p
    /// ```
    ///
    /// then the entries in this array are
    /// `(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)`.
    pub matrix: [f32; 16],
}

impl fidl::Persistable for Transform {}

/// Represents a 2D vector with integer coordinates.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Vec_{
    pub x: i32,
    pub y: i32,
}

impl fidl::Persistable for Vec_ {}

/// Represents a 3D vector with floating point coordinates.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Vec3F{
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl fidl::Persistable for Vec3F {}

/// Represents a 4D vector with floating point coordinates.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Vec4F{
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl fidl::Persistable for Vec4F {}

/// Represents a 2D vector with floating point coordinates.
///
/// This type does not specify units. Protocols that use this type should
/// specify the characteristics of the vector space, including orientation and
/// units.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct VecF{
    pub x: f32,
    pub y: f32,
}

impl fidl::Persistable for VecF {}

mod internal {
    use super::*;
    
unsafe impl fidl::encoding::TypeMarker for Inset {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for Inset {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Inset> for &Inset {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Inset>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Inset).write_unaligned((self as *const Inset).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<i32>, T1: fidl::encoding::Encode<i32>, T2: fidl::encoding::Encode<i32>, T3: fidl::encoding::Encode<i32>,>
    fidl::encoding::Encode<Inset> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Inset>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Inset {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            top: fidl::new_empty!(i32),
            right: fidl::new_empty!(i32),
            bottom: fidl::new_empty!(i32),
            left: fidl::new_empty!(i32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for InsetF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
}
impl fidl::encoding::ValueTypeMarker for InsetF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<InsetF> for &InsetF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<InsetF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<InsetF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.top),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.right),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.bottom),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.left),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>, T3: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<InsetF> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<InsetF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for InsetF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            top: fidl::new_empty!(f32),
            right: fidl::new_empty!(f32),
            bottom: fidl::new_empty!(f32),
            left: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.top, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.right, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.bottom, decoder, offset + 8, _depth)?;
            fidl::decode!(f32, &mut self.left, decoder, offset + 12, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Point {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for Point {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Point> for &Point {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Point>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Point).write_unaligned((self as *const Point).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<i32>, T1: fidl::encoding::Encode<i32>,>
    fidl::encoding::Encode<Point> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Point>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Point {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(i32),
            y: fidl::new_empty!(i32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Point3F {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        12
    }
}
impl fidl::encoding::ValueTypeMarker for Point3F {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Point3F> for &Point3F {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Point3F>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Point3F>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.z),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<Point3F> for ( T0, T1, T2,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Point3F>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Point3F {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
            z: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.z, decoder, offset + 8, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for PointF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
}
impl fidl::encoding::ValueTypeMarker for PointF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<PointF> for &PointF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<PointF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<PointF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<PointF> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<PointF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for PointF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for RRectF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        48
    }
}
impl fidl::encoding::ValueTypeMarker for RRectF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<RRectF> for &RRectF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RRectF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<RRectF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.width),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.height),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.top_left_radius_x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.top_left_radius_y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.top_right_radius_x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.top_right_radius_y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.bottom_left_radius_x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.bottom_left_radius_y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.bottom_right_radius_x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.bottom_right_radius_y),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>, T3: fidl::encoding::Encode<f32>, T4: fidl::encoding::Encode<f32>, T5: fidl::encoding::Encode<f32>, T6: fidl::encoding::Encode<f32>, T7: fidl::encoding::Encode<f32>, T8: fidl::encoding::Encode<f32>, T9: fidl::encoding::Encode<f32>, T10: fidl::encoding::Encode<f32>, T11: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<RRectF> for ( T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RRectF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        self.4.encode(encoder, offset + 16, depth)?;
        self.5.encode(encoder, offset + 20, depth)?;
        self.6.encode(encoder, offset + 24, depth)?;
        self.7.encode(encoder, offset + 28, depth)?;
        self.8.encode(encoder, offset + 32, depth)?;
        self.9.encode(encoder, offset + 36, depth)?;
        self.10.encode(encoder, offset + 40, depth)?;
        self.11.encode(encoder, offset + 44, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for RRectF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
            width: fidl::new_empty!(f32),
            height: fidl::new_empty!(f32),
            top_left_radius_x: fidl::new_empty!(f32),
            top_left_radius_y: fidl::new_empty!(f32),
            top_right_radius_x: fidl::new_empty!(f32),
            top_right_radius_y: fidl::new_empty!(f32),
            bottom_left_radius_x: fidl::new_empty!(f32),
            bottom_left_radius_y: fidl::new_empty!(f32),
            bottom_right_radius_x: fidl::new_empty!(f32),
            bottom_right_radius_y: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.width, decoder, offset + 8, _depth)?;
            fidl::decode!(f32, &mut self.height, decoder, offset + 12, _depth)?;
            fidl::decode!(f32, &mut self.top_left_radius_x, decoder, offset + 16, _depth)?;
            fidl::decode!(f32, &mut self.top_left_radius_y, decoder, offset + 20, _depth)?;
            fidl::decode!(f32, &mut self.top_right_radius_x, decoder, offset + 24, _depth)?;
            fidl::decode!(f32, &mut self.top_right_radius_y, decoder, offset + 28, _depth)?;
            fidl::decode!(f32, &mut self.bottom_left_radius_x, decoder, offset + 32, _depth)?;
            fidl::decode!(f32, &mut self.bottom_left_radius_y, decoder, offset + 36, _depth)?;
            fidl::decode!(f32, &mut self.bottom_right_radius_x, decoder, offset + 40, _depth)?;
            fidl::decode!(f32, &mut self.bottom_right_radius_y, decoder, offset + 44, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for RatioU32 {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for RatioU32 {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<RatioU32> for &RatioU32 {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RatioU32>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut RatioU32).write_unaligned((self as *const RatioU32).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<u32>, T1: fidl::encoding::Encode<u32>,>
    fidl::encoding::Encode<RatioU32> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RatioU32>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for RatioU32 {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            numerator: fidl::new_empty!(u32),
            denominator: fidl::new_empty!(u32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for RatioU64 {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        8
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for RatioU64 {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<RatioU64> for &RatioU64 {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RatioU64>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut RatioU64).write_unaligned((self as *const RatioU64).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<u64>, T1: fidl::encoding::Encode<u64>,>
    fidl::encoding::Encode<RatioU64> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RatioU64>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 8, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for RatioU64 {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            numerator: fidl::new_empty!(u64),
            denominator: fidl::new_empty!(u64),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Rect {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for Rect {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Rect> for &Rect {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Rect>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Rect).write_unaligned((self as *const Rect).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<i32>, T1: fidl::encoding::Encode<i32>, T2: fidl::encoding::Encode<i32>, T3: fidl::encoding::Encode<i32>,>
    fidl::encoding::Encode<Rect> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Rect>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Rect {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(i32),
            y: fidl::new_empty!(i32),
            width: fidl::new_empty!(i32),
            height: fidl::new_empty!(i32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for RectF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
}
impl fidl::encoding::ValueTypeMarker for RectF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<RectF> for &RectF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RectF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<RectF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.width),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.height),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>, T3: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<RectF> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RectF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for RectF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
            width: fidl::new_empty!(f32),
            height: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.width, decoder, offset + 8, _depth)?;
            fidl::decode!(f32, &mut self.height, decoder, offset + 12, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for RectU {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for RectU {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<RectU> for &RectU {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RectU>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut RectU).write_unaligned((self as *const RectU).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<u32>, T1: fidl::encoding::Encode<u32>, T2: fidl::encoding::Encode<u32>, T3: fidl::encoding::Encode<u32>,>
    fidl::encoding::Encode<RectU> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<RectU>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for RectU {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(u32),
            y: fidl::new_empty!(u32),
            width: fidl::new_empty!(u32),
            height: fidl::new_empty!(u32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Size {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for Size {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Size> for &Size {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Size>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Size).write_unaligned((self as *const Size).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<i32>, T1: fidl::encoding::Encode<i32>,>
    fidl::encoding::Encode<Size> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Size>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Size {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            width: fidl::new_empty!(i32),
            height: fidl::new_empty!(i32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for SizeF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
}
impl fidl::encoding::ValueTypeMarker for SizeF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<SizeF> for &SizeF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<SizeF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<SizeF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.width),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.height),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<SizeF> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<SizeF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for SizeF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            width: fidl::new_empty!(f32),
            height: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.width, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.height, decoder, offset + 4, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for SizeU {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for SizeU {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<SizeU> for &SizeU {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<SizeU>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut SizeU).write_unaligned((self as *const SizeU).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<u32>, T1: fidl::encoding::Encode<u32>,>
    fidl::encoding::Encode<SizeU> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<SizeU>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for SizeU {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            width: fidl::new_empty!(u32),
            height: fidl::new_empty!(u32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Transform {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        64
    }
}
impl fidl::encoding::ValueTypeMarker for Transform {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Transform> for &Transform {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Transform>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Transform>::encode(
                (
                    <fidl::encoding::Array<f32, 16> as fidl::encoding::ValueTypeMarker>::borrow(&self.matrix),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<fidl::encoding::Array<f32, 16>>,>
    fidl::encoding::Encode<Transform> for ( T0,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Transform>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Transform {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            matrix: fidl::new_empty!(fidl::encoding::Array<f32, 16>),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(fidl::encoding::Array<f32, 16>, &mut self.matrix, decoder, offset + 0, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Vec_ {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
    #[inline(always)]
    fn encode_is_copy() -> bool {
        true
    }

    #[inline(always)]
    fn decode_is_copy() -> bool {
        true
    }
}
impl fidl::encoding::ValueTypeMarker for Vec_ {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Vec_> for &Vec_ {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec_>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Vec_).write_unaligned((self as *const Vec_).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
    }
}
unsafe impl< T0: fidl::encoding::Encode<i32>, T1: fidl::encoding::Encode<i32>,>
    fidl::encoding::Encode<Vec_> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec_>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Vec_ {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(i32),
            y: fidl::new_empty!(i32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Vec3F {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        12
    }
}
impl fidl::encoding::ValueTypeMarker for Vec3F {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Vec3F> for &Vec3F {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec3F>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Vec3F>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.z),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<Vec3F> for ( T0, T1, T2,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec3F>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Vec3F {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
            z: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.z, decoder, offset + 8, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for Vec4F {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
}
impl fidl::encoding::ValueTypeMarker for Vec4F {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<Vec4F> for &Vec4F {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec4F>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Vec4F>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.z),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.w),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>, T3: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<Vec4F> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Vec4F>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for Vec4F {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
            z: fidl::new_empty!(f32),
            w: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.z, decoder, offset + 8, _depth)?;
            fidl::decode!(f32, &mut self.w, decoder, offset + 12, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for VecF {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        8
    }
}
impl fidl::encoding::ValueTypeMarker for VecF {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<VecF> for &VecF {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<VecF>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VecF>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.x),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.y),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<VecF> for ( T0, T1,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<VecF>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for VecF {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            x: fidl::new_empty!(f32),
            y: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.x, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.y, decoder, offset + 4, _depth)?;
            Ok(())
    }
}
}