// WARNING: This file is machine generated by fidlgen.


#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
    fidl::{
        endpoints::{ControlHandle as _, Responder as _},
        client::QueryResponseFut,
    },
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

/// Represents a color without alpha channel. Range per channel is usually
/// between 0.0 and 1.0.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct ColorRgb{
    pub red: f32,
    pub green: f32,
    pub blue: f32,
}

impl fidl::Persistable for ColorRgb {}

/// Represents a color. Interfaces that use this struct should document whether
/// or not the floats have been premultiplied by alpha. Range per channel is
/// usually between 0.0 and 1.0.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct ColorRgba{
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}

impl fidl::Persistable for ColorRgba {}

mod internal {
    use super::*;
    
unsafe impl fidl::encoding::TypeMarker for ColorRgb {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        12
    }
}
impl fidl::encoding::ValueTypeMarker for ColorRgb {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<ColorRgb> for &ColorRgb {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<ColorRgb>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ColorRgb>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.red),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.green),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.blue),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<ColorRgb> for ( T0, T1, T2,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<ColorRgb>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for ColorRgb {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            red: fidl::new_empty!(f32),
            green: fidl::new_empty!(f32),
            blue: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.red, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.green, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.blue, decoder, offset + 8, _depth)?;
            Ok(())
    }
}
    
unsafe impl fidl::encoding::TypeMarker for ColorRgba {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        4
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        16
    }
}
impl fidl::encoding::ValueTypeMarker for ColorRgba {
    type Borrowed<'a> = &'a Self;
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        value
    }
}

unsafe impl fidl::encoding::Encode<ColorRgba> for &ColorRgba {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<ColorRgba>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ColorRgba>::encode(
                (
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.red),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.green),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.blue),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.alpha),
                ),
                encoder, offset, _depth
            )
    }
}
unsafe impl< T0: fidl::encoding::Encode<f32>, T1: fidl::encoding::Encode<f32>, T2: fidl::encoding::Encode<f32>, T3: fidl::encoding::Encode<f32>,>
    fidl::encoding::Encode<ColorRgba> for ( T0, T1, T2, T3,)
{
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<ColorRgba>(offset);
        // Zero out padding regions. There's no need to apply masks
        // because the unmasked parts will be overwritten by fields.
        // Write the fields.
        self.0.encode(encoder, offset + 0, depth)?;
        self.1.encode(encoder, offset + 4, depth)?;
        self.2.encode(encoder, offset + 8, depth)?;
        self.3.encode(encoder, offset + 12, depth)?;
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for ColorRgba {
    #[inline(always)]
    fn new_empty() -> Self {
        Self {
            red: fidl::new_empty!(f32),
            green: fidl::new_empty!(f32),
            blue: fidl::new_empty!(f32),
            alpha: fidl::new_empty!(f32),
        }
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(f32, &mut self.red, decoder, offset + 0, _depth)?;
            fidl::decode!(f32, &mut self.green, decoder, offset + 4, _depth)?;
            fidl::decode!(f32, &mut self.blue, decoder, offset + 8, _depth)?;
            fidl::decode!(f32, &mut self.alpha, decoder, offset + 12, _depth)?;
            Ok(())
    }
}
}